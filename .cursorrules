# TrendForge Project Rules

## 📋 项目概述

TrendForge 是一个基于深度内容分析和社交趋势的 YouTube 频道内容推荐系统，采用模块化设计，包含后端（FastAPI + Python）和前端（Next.js + TypeScript）。

## 🏗️ 项目架构

### 目录结构
```
TrendForge/
├── backend/                    # 后端服务
│   ├── services/               # 核心业务逻辑模块
│   │   ├── enhanced_youtube_analyzer.py    # 内容分析器（NLP）
│   │   ├── enhanced_social_collector.py    # 社交趋势收集器（MVP 3.0）
│   │   ├── predictive_recommender.py       # 智能推荐引擎（MVP 3.0）
│   │   ├── trend_predictor.py              # Prophet 时间序列预测
│   │   ├── ml_predictor.py                 # ML 模型预测器
│   │   └── backtest_analyzer.py            # 回测分析器
│   ├── app_v2.py               # FastAPI 主应用
│   ├── requirements_v2.txt     # Python 依赖
│   └── .env                    # 环境变量
├── frontend/                    # 前端应用
│   ├── app/                    # Next.js App Router
│   │   ├── api/                # API 路由
│   │   ├── analysis/           # 分析页面
│   │   └── page.tsx            # 首页
│   ├── components/             # React 组件
│   ├── lib/                    # 工具函数
│   └── prisma/                 # 数据库 Schema
└── ALGORITHM_DOCUMENTATION.md  # 算法文档
```

### 技术栈

**后端:**
- Python 3.9+
- FastAPI (Web 框架)
- SQLAlchemy (ORM，可选)
- Prisma (通过前端使用)
- spaCy, NLTK, KeyBERT (NLP)
- scikit-learn, XGBoost, LightGBM (ML)
- Prophet (时间序列预测)
- Tweepy, PRAW, Pytrends (社交媒体 API)
- Redis (可选缓存)

**前端:**
- Next.js 14 (App Router)
- TypeScript
- React 18
- Tailwind CSS
- Prisma (数据库 ORM)
- Recharts (数据可视化)
- Lucide React (图标)

**数据库:**
- PostgreSQL

## 📝 编码规范

### Python 后端

**命名规则:**
- 类名: `PascalCase` (如 `EnhancedContentAnalyzer`)
- 函数/方法名: `snake_case` (如 `analyze_channel_deeply`)
- 常量: `UPPER_SNAKE_CASE` (如 `TWITTER_AVAILABLE`)
- 私有方法: `_leading_underscore` (如 `_calculate_match_score`)
- 模块级实例: `snake_case` (如 `recommendation_engine`)

**文件组织:**
- 每个服务模块独立文件
- 模块顶部导入标准库，然后是第三方库，最后是本地模块
- 使用类型提示 (`from typing import List, Dict, Optional`)
- 异步函数使用 `async/await`

**错误处理:**
- 使用 try-except 捕获异常
- 打印错误信息并继续执行（不中断主流程）
- API 限流时使用模拟数据作为 fallback
- 关键错误使用 `HTTPException` 返回给前端

**日志:**
- 使用 `print()` 输出关键步骤和状态
- 格式: `✅ 成功`, `⚠️ 警告`, `❌ 错误`, `ℹ️ 信息`
- 重要操作添加步骤编号: `Step 1/4: ...`

### TypeScript 前端

**命名规则:**
- 组件名: `PascalCase` (如 `TrendPredictionChart`)
- 函数/变量: `camelCase` (如 `fetchResults`)
- 常量: `UPPER_SNAKE_CASE` (如 `API_URL`)
- 接口/类型: `PascalCase` (如 `Recommendation`)
- Props 接口: `Props` 后缀 (如 `TrendPredictionChartProps`)

**文件组织:**
- 使用 Next.js App Router (`app/` 目录)
- API 路由: `app/api/[route]/route.ts`
- 页面: `app/[path]/page.tsx`
- 组件: `components/[ComponentName].tsx`
- 工具函数: `lib/[module].ts`

**React 模式:**
- 使用函数组件和 Hooks
- `'use client'` 指令用于客户端组件
- 状态管理: `useState`, `useEffect`
- 数据获取: 在 `useEffect` 中调用 API

**样式:**
- 使用 Tailwind CSS 类名
- 深色主题: `bg-slate-900`, `text-white`, `text-purple-300`
- 渐变: `bg-gradient-to-br from-slate-900 via-purple-900 to-slate-900`
- 响应式: `md:grid-cols-5`, `sm:text-lg`

## 🔑 关键业务逻辑

### 1. 内容分析流程

```
视频数据 → EnhancedContentAnalyzer
  ├── extract_topics_from_titles (TF-IDF + NER + KeyBERT)
  ├── analyze_high_performing_videos (前20%视频分析)
  ├── identify_content_style (风格识别)
  └── EnhancedAudienceAnalyzer.analyze_target_audience (受众分析)
```

### 2. 社交趋势收集流程

```
关键词 → EnhancedSocialMediaAggregator
  ├── EnhancedTwitterCollector (速率限制 + 缓存)
  ├── EnhancedRedditCollector (速率限制 + 缓存)
  ├── EnhancedGoogleTrendsCollector (速率限制 + 缓存)
  └── CrossPlatformSignalAggregator (聚合 + 综合评分)
```

### 3. 推荐生成流程

```
频道分析 + 社交趋势 → PredictiveRecommendationEngine
  ├── _calculate_match_score (匹配分数计算)
  │   ├── viral_potential × 40%
  │   ├── performance_score × 25%
  │   └── relevance_score × 35%
  ├── _enhance_with_predictions (Prophet 预测增强)
  │   └── final_score = current_match × 60% + predictive × 40%
  └── 排序并返回 Top N
```

### 4. 预测流程

```
历史数据 → TrendPredictionEngine
  ├── get_historical_data (从数据库或生成模拟数据)
  ├── Prophet 模型训练
  ├── 7天预测生成
  └── 趋势方向、峰值、置信度分析
```

### 5. 回测流程

```
历史视频 → BacktestAnalyzer
  ├── 按月分组计算同期平均
  ├── ML 模型训练（如果数据量 >= 20）
  ├── 对每个视频进行预测
  ├── 计算准确度指标 (MAE, MAPE, RMSE, R², Correlation)
  └── 识别 Outlier (actual_views > period_avg × 1.2)
```

## 🎯 核心算法参数

### 匹配分数算法
```python
match_score = (
    viral_potential * 0.4 +      # 互联网热度 (40%)
    performance_score * 0.25 +   # 表现潜力 (25%)
    relevance_score * 0.35        # 内容相关性 (35%)
)
```

### 预测播放量算法
```python
predicted_views = (
    base_views *                  # 基准播放量（中位数70% + 平均值30%）
    viral_multiplier *            # 热度系数 (0.7-3.0)
    relevance_multiplier *        # 相关性系数 (0.7-1.3)
    performance_multiplier *      # 表现潜力系数 (0.7-1.5)
    timeliness_multiplier *       # 时效性系数 (0.9-1.15)
    channel_stability *           # 频道稳定性 (0.95-1.1)
    title_optimization *          # 标题优化 (0.98-1.05)
    confidence_factor             # 置信度因子 (0.8-1.1)
)
```

### ML 模型参数
- **对数变换**: CV > 0.5 时自动启用
- **异常值处理**: 3-sigma 规则 (mean ± 3*std)
- **特征选择**: SelectKBest, k=20
- **交叉验证**: 5-Fold KFold (如果 n_samples >= 20)
- **测试集比例**: 30-40% (最小 10 个样本)
- **模型选择**: R²×50% + MAPE×30% + relative_MAE×20%

### 社交趋势聚合算法
```python
composite_score = (
    twitter_score * 0.3 +         # Twitter (30%)
    reddit_score * 0.3 +          # Reddit (30%)
    google_score * 0.4 +          # Google Trends (40%)
    source_bonus +                # 跨平台加成 (+8 或 +15)
    direction_bonus +              # 趋势方向加成 (+5)
    sentiment_bonus                # 情感加成 (+3)
)
```

## 🚫 禁忌和注意事项

### 绝对禁止
1. ❌ **不要硬编码 API 密钥** - 必须使用环境变量
2. ❌ **不要在前端暴露敏感信息** - API 密钥、数据库 URL 等
3. ❌ **不要修改数据库 Schema 而不更新 Prisma** - 必须先更新 `schema.prisma`，然后 `prisma db push`
4. ❌ **不要使用同步阻塞操作** - 使用 `async/await` 处理 I/O
5. ❌ **不要忽略错误处理** - 所有 API 调用都要有 try-except

### 代码质量
1. ⚠️ **避免 Python 模块缓存问题** - 修改服务模块后，清理 `__pycache__` 并重启服务器
2. ⚠️ **避免过拟合** - ML 模型使用正则化和交叉验证
3. ⚠️ **避免 API 限流** - 使用速率限制器和缓存
4. ⚠️ **避免数据不一致** - 确保前后端数据格式匹配

### 性能优化
1. ✅ **使用缓存** - Redis 或本地缓存减少 API 调用
2. ✅ **并行处理** - 使用 `asyncio.gather` 并行收集社交趋势
3. ✅ **批量操作** - 批量预测、批量数据库查询
4. ✅ **懒加载** - 前端组件按需加载

## 📊 数据模型

### 数据库 Schema (Prisma)
```prisma
model User {
  id        String   @id @default(uuid())
  email     String   @unique
  channels  Channel[]
}

model Channel {
  id          String        @id @default(uuid())
  channelId   String        @unique
  title       String
  fingerprint Json          // 存储完整分析结果
  trends      ChannelTrend[]
}

model ChannelTrend {
  id                String   @id @default(uuid())
  channelId         String
  matchScore        Float
  recommendationData Json?   // 存储完整推荐数据
  trend             Trend    @relation(...)
}
```

### API 响应格式

**Full Analysis Response:**
```typescript
{
  success: boolean,
  channel_analysis: {
    topics: Array<{topic: string, score: number}>,
    content_style: {...},
    target_audience: {...},
    high_performers: {...}
  },
  social_trends: {
    merged_trends: Array<{...}>,
    source_breakdown: {...}
  },
  recommendations: Array<{
    keyword: string,
    match_score: number,
    viral_potential: number,
    prediction?: {...},  // Prophet 预测（如果可用）
    ...
  }>,
  trend_predictions?: Array<{...}>,  // 趋势预测（如果可用）
  backtest?: {...}  // 回测结果（如果启用）
}
```

## 🔧 常用模式

### 后端模式

**服务模块初始化:**
```python
# 在 app_v2.py 中
from services.module_name import ServiceClass
service_instance = ServiceClass(config)
```

**异步 API 端点:**
```python
@app.post("/api/v2/endpoint")
async def endpoint(request: RequestModel):
    try:
        result = await service_method(request.data)
        return {"success": True, "data": result}
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))
```

**错误处理和 Fallback:**
```python
try:
    result = await api_call()
except TooManyRequests:
    print("⚠️ Rate limit hit, using mock data")
    result = generate_mock_data()
except Exception as e:
    print(f"❌ Error: {e}")
    result = default_value
```

### 前端模式

**数据获取:**
```typescript
useEffect(() => {
  const fetchData = async () => {
    try {
      const res = await fetch(`/api/endpoint/${id}`);
      const data = await res.json();
      setData(data);
    } catch (error) {
      console.error('Failed to fetch:', error);
    } finally {
      setLoading(false);
    }
  };
  fetchData();
}, [id]);
```

**条件渲染:**
```typescript
{data?.section && data.section.length > 0 ? (
  <div>显示内容</div>
) : (
  <div>暂无数据</div>
)}
```

## 🎨 UI/UX 规范

### 颜色方案
- **主背景**: `bg-gradient-to-br from-slate-900 via-purple-900 to-slate-900`
- **卡片背景**: `bg-white/10 backdrop-blur-md`
- **边框**: `border border-white/20`
- **主色调**: 紫色 (`text-purple-400`, `bg-purple-600`)
- **成功/上升**: 绿色 (`text-green-400`)
- **警告/下降**: 红色 (`text-red-400`)
- **高亮**: 黄色 (`text-yellow-400`)

### 组件样式
- **圆角**: `rounded-xl` (卡片), `rounded-lg` (按钮)
- **间距**: `p-6` (卡片), `mb-8` (section 间距)
- **字体**: `text-xl font-bold` (标题), `text-sm text-purple-300` (辅助文本)

### 图标使用
- 使用 `lucide-react` 图标库
- 图标大小: `w-6 h-6` (标准), `w-5 h-5` (小), `w-4 h-4` (很小)

## 🔄 版本管理

### 当前版本
- **后端**: MVP 3.0
- **前端**: MVP 2.0
- **算法**: v2.1 (跨频道一致性优化)

### 版本升级原则
1. 保持向后兼容性
2. 新功能通过新模块实现，不破坏现有代码
3. 使用 try-except 导入新模块，失败时回退到旧版本
4. 重大变更更新版本号

## 📚 文档和注释

### 代码注释
- 类和方法使用 docstring
- 复杂算法添加行内注释
- 关键参数说明用途和范围

### 文档文件
- `ALGORITHM_DOCUMENTATION.md` - 算法详细说明
- `DEPLOYMENT.md` - 部署指南
- `QUICK_START.md` - 快速开始指南

## 🧪 测试和调试

### 调试技巧
1. **Python 模块缓存**: 清理 `__pycache__` 和 `.pyc` 文件
2. **后端日志**: 查看 `/tmp/backend.log`
3. **前端控制台**: 检查浏览器开发者工具
4. **API 测试**: 使用 `curl` 或 Postman

### 常见问题
1. **模块导入错误**: 检查 `sys.path` 和相对导入
2. **数据库连接**: 检查 `.env` 中的 `DATABASE_URL`
3. **API 限流**: 检查速率限制器和缓存
4. **前端构建错误**: 检查 TypeScript 类型错误

## 🔐 安全规范

1. **环境变量**: 所有敏感信息存储在 `.env` 文件中
2. **CORS**: 配置允许的源，生产环境使用具体域名
3. **API 密钥**: 使用 URL 解码处理编码的 token
4. **数据验证**: 使用 Pydantic 模型验证请求数据
5. **错误信息**: 不向客户端暴露敏感错误详情

## 🚀 部署规范

### 环境变量
- **后端**: `TWITTER_BEARER_TOKEN`, `REDDIT_CLIENT_ID`, `REDDIT_CLIENT_SECRET`, `DATABASE_URL`, `REDIS_URL` (可选)
- **前端**: `BACKEND_SERVICE_URL`, `YOUTUBE_API_KEY`, `DATABASE_URL`

### 构建命令
- **后端**: `python app_v2.py` (开发), `gunicorn app_v2:app` (生产)
- **前端**: `pnpm dev` (开发), `pnpm build && pnpm start` (生产)

### 数据库迁移
```bash
cd frontend
pnpm prisma db push
pnpm prisma generate
```

## 📌 关键约定

1. **数据存储**: 完整分析结果存储在 `channel.fingerprint.v2_analysis`
2. **推荐数据**: 存储在 `ChannelTrend.recommendationData` JSON 字段
3. **回测数据**: 存储在 `channel.fingerprint.v2_analysis.backtest`
4. **趋势预测**: 存储在 `channel.fingerprint.v2_analysis.trend_predictions`
5. **向后兼容**: 旧数据自动使用 fallback 逻辑重新计算

## 🎯 开发工作流

1. **新功能开发**: 创建新服务模块，在主应用中集成
2. **算法优化**: 更新算法文档，记录参数变更
3. **前端更新**: 更新 TypeScript 类型，确保类型安全
4. **测试**: 本地测试后部署到开发环境
5. **文档**: 更新相关文档和注释

## 💡 最佳实践

1. **模块化设计**: 每个功能独立模块，便于测试和维护
2. **错误恢复**: 关键功能失败时使用 fallback，不中断主流程
3. **性能优化**: 使用缓存、并行处理、批量操作
4. **用户体验**: 加载状态、错误提示、空状态处理
5. **代码复用**: 提取公共逻辑到工具函数

## 📚 相关文档

### 项目文档索引

1. **`.cursorrules`** (本文件)
   - 用途: 编码规范、架构约定、技术栈偏好
   - 受众: Cursor AI 和开发团队
   - 更新频率: 架构或规范变更时

2. **`project-memory.md`**
   - 用途: 历史重要结论、决策记录、优化历程
   - 受众: 开发团队和新成员
   - 更新频率: 每次重大变更或重要决策后
   - 引用方式: 在 Cursor 中使用 `@project-memory.md`

3. **`ALGORITHM_DOCUMENTATION.md`**
   - 用途: 算法详细说明、模型参数、评估指标
   - 受众: 算法工程师和开发团队
   - 更新频率: 算法变更时

4. **`DEPLOYMENT.md`**
   - 用途: 部署指南、环境配置、运维说明
   - 受众: DevOps 和部署人员
   - 更新频率: 部署流程变更时

### 文档配合使用流程

**开发新功能时:**
1. 查看 `.cursorrules` 了解编码规范和架构约定
2. 查看 `project-memory.md` 了解相关历史决策和优化经验
3. 参考 `ALGORITHM_DOCUMENTATION.md` 了解算法细节（如涉及算法）
4. 遵循规范进行开发
5. 完成后更新 `project-memory.md` 记录新决策

**解决问题时:**
1. 查看 `project-memory.md` 的"关键问题与解决方案"部分
2. 参考 `.cursorrules` 的"禁忌和注意事项"部分
3. 如果问题已解决，更新 `project-memory.md` 的"技术债务记录"

**代码审查时:**
1. 对照 `.cursorrules` 检查编码规范
2. 参考 `project-memory.md` 确保遵循历史最佳实践
3. 确保新代码符合架构决策

**新成员入职:**
1. 先阅读 `.cursorrules` 了解项目规范
2. 阅读 `project-memory.md` 了解项目历史
3. 参考 `ALGORITHM_DOCUMENTATION.md` 了解技术细节
4. 查看 `DEPLOYMENT.md` 了解部署流程

---

**最后更新**: 2024-01-13
**维护者**: TrendForge 开发团队
